% Copyright (C) 2023 Commonwealth of Australia
%   Micah Brown
%   Brendan Mahony
%   Jim McCarthy

% This file is part of Ironbark.

% This program is free software: you can redistribute it and/or modify it under the terms of 
% the GNU General Public License as published by the Free Software Foundation, either 
% version 3 of the License, or (at your option) any later version.

% This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
% without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
% PURPOSE. See the GNU General Public License for more details.

% You should have received a copy of the GNU General Public License along with
% this program. If not, see <https://www.gnu.org/licenses/>.

\documentclass[11pt,a4paper]{article}
\usepackage{isabelle,isabellesym}
\usepackage{amssymb}

\newenvironment{matharray}[1]{\[\begin{array}{#1}}{\end{array}\]}

% for uniform font size
%\renewcommand{\isastyle}{\isastyleminor}

% this should be the last package used
\usepackage{pdfsetup}

% urls in roman style, theory text in math-similar italics
\urlstyle{rm}
\isabellestyle{default}

% for uniform font size
%\renewcommand{\isastyle}{\isastyleminor}
    \oddsidemargin -.1 in      %   Note that \oddsidemargin = \evensidemargin
    \evensidemargin -.1in
    \textwidth 6.5 in % Width of text line.

\begin{document}

\title{The Ironbark Formal Model}
\author{Micah Brown, Brendan Mahony, Jim McCarthy}
\maketitle

\noindent Copyright (C) 2023 Commonwealth of Australia\\
\indent Micah Brown\\
\indent Brendan Mahony\\
\indent Jim McCarthy\\
\\
This file is part of Ironbark.\\
\\
This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\
\\
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\
\\
You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

\tableofcontents

% sane default for proof documents
\parindent 0pt\parskip 0.5ex

\newpage

\newpage

\section{Overview}
In this section, we provide an overview of the structure of the Ironbark formal model.

The remainder of this document contains the output generated by Isabelle for the Ironbark formal model. The formal model is built for the 2023 version of Isabelle.

\subsection{Design}
We provide a brief overview of the design of the Ironbark processor which we model, but this is not intended to be a complete specification. For a complete specification, we refer the interested reader to the implementation of the Ironbark processor in our formal model.

The Ironbark processor can be broken down into the following conceptual components:

\begin{itemize}
  \item flags
  \item registers
  \item memory
  \item instruction decoding and execution logic.
\end{itemize}

Flags, registers, and memory provide the state of the processor. Instructions provide the mechanisms for changing that state.

The Ironbark memory architecture takes inspiration from the Harvard architecture, which has separate memory for the executable program and data. In the Ironbark architecture, we have six separate memory spaces, which are:

\begin{itemize}
  \item program memory
  \item call memory
  \item statically allocated memory (“Static memory”)
  \item dynamically allocated memory (“Dynamic memory”)
  \item input memory
  \item output memory.
\end{itemize}

Program memory holds the code for execution.

Call memory holds the call stack, which is made of fixed size frames, which include various register backups.

Input memory provides a memory mapped interface to inputs to the processor from the outside world.

Conversely, output memory provides a memory mapped interface for the processor to talk to the outside world.

In contrast with most modern processors, we do not include components for performance optimisation, such as a cache, or a branch predictor. This comes at a performance cost, but greatly simplifies the processor, and makes it much easier to reason about.

Ironbark employs a philosophy of “1 processor, 1 process, 1 thread”, and does not support the use of threads, context switching, or other forms of parallelism. If an application benefits from having two processes running in parallel, two processors would be required, with the appropriate mapping of their input and output memories.

\subsection{Layers}
This document presents the Isabelle theories for the Ironbark processor. In understanding the theories, it is beneficial to understand how we have structured our formal model.

We divide our model into five layers, where each one builds on the one before it:
\begin{itemize}
  \item preliminary
  \item state
  \item state manipulation
  \item instruction
  \item execution
\end{itemize}

The preliminary layer is unique from the other layers, and does not follow much of the pattern or structure of the other layers. It exists solely to provide rules that are not part of the Isabelle libraries that we build on. In particular, the rules included in preliminary are for properties we rely on, but are not particularly related to Ironbark.

The state layer defines the state of the Ironbark processor in Isabelle, and provides some results relating to how it is defined. The results in this layer are trivially derived from the definitions we use.

The state manipulation layer defines how the state can be manipulated, expressed in the underlying Isabelle/HOL semantics. It also provides some basic results on how those definitions work. The results in this layer are trivially derived from the definitions we use.

The instruction layer defines the instructions of the Ironbark architecture in terms of the state manipulation operations. It also provides some results relating to the operation of instructions. The results in this layer are trivially derived from the definitions we use.

The execution layer defines how the execution of the processor develops in terms of instructions and the state manipulation operations. It also proves various properties about the execution of the Ironbark processor. It is at this layer that it becomes possible to describe many of the desired security properties of the Ironbark processor.

On top of the execution layer we have some additional work. This includes variations on showing the correctness of an implementation of the Fibonacci function, and the correctness of a simple program that does 1 + 1.

\subsection{Sublayers}
In constructing the definitions and proofs at each layer (other than preliminary), we subdivide the layer into some or all of the following sublayers, in the following order:
\begin{itemize}
  \item implementations
  \item auxiliary
  \item decomposition
  \item simplification
  \item reordering
  \item interface
\end{itemize}

The implementations sublayer is for providing definitions. It contains no lemmas.

The auxiliary sublayer is included as a pro forma import point for the sections that follow. It is also used to import the results of the layer below. It may also contain auxiliary results that do not fit into any of the other sublayers.

The decomposition (often denoted `decomp') sublayer provides lemmas that are for decomposing a layer into the layer below it. The rules in this sublayer are typically trivially derived from the definitions of the functions involved.

The simplification (often denoted `simp') sublayer provides lemmas that are for simplifying the proof state. These are typically formed by enumerating pairings of read and write operations on state components and showing they can be expressed in either one or zero operation(s). In the instruction layer, these rules are aimed at eliminating the instruction from the goal. To aid users in finding simplification rules, they are typically ordered based on the normalised ordering (see \ref{sec: Normalised Forms}). The rules in this sublayer are typically trivially derived from the definitions of the functions involved. 

The reordering sublayer provides lemmas that are for changing the order that functions are applied. To avoid creating infinite loops from these rules, we only create reordering rules that lead to a `normalised' form, which we define below. Any arbitrary ordering can be derived from this by applying the corresponding rule in the appropriate direction. We note that while we define this ordering, we do not have rules which cover all reorderings. This is because we found reordering to rarely be needed, and only created rules when we had a need for them.

The interface sublayer (typically in files named `\_top') gathers related lemmas together for easier reference. It also provides a single point for higher layers to import.

Each layer may also contain additional components or divisions as needed, especially when there are noteworthy results, but this is a rough guide for the general structure of the boilerplate results we work from.

\subsubsection{Normalised Forms} \label{sec: Normalised Forms}
The normalised form for reordering rules has the highest layer applied last.

Within the state manipulation layer, the following ordering is applied (from applied last, to applied first):
\begin{itemize}
  \item operators on flags 
  \begin{itemize}
    \item clear (see sub-ordering for set)
    \item set 
    \begin{itemize}
      \item end return
      \item end call
      \item end jump
      \item halt
      \item error
    \end{itemize}
  \end{itemize}
  \item operators on registers (ordered by register index; highest index applied first)
  \item operators on memory
  \begin{itemize}
    \item program memory
    \item call memory
    \item static memory
    \item dynamic memory
    \item input memory
    \item output memory
  \end{itemize}
  \item special operators
  \begin{itemize}
    \item standard post instruction
    \item backup registers before call
    \item restore registers after call
    \item standard error
  \end{itemize}
\end{itemize}

Within the instruction layer, reordering is done with highest opcode number applied first.

\section{Ironbark Implementation}
\input{state/state/state_implementations}
\input{state_manipulation/state_manipulation/state_manipulation_implementations}
\input{instruction/instruction/instruction_implementations}
\input{execution/execution/execution_implementations}

\section{Key Results}
\input{execution/execution/security_properties}

\input{fibonacci_function}

\appendix

\section{Preliminaries}
\input{prelim/prelim/preliminaries}

\section{State Level Lemmas}
\input{state/state/state_auxiliary}
\input{state/state/register_sets}
\subsection{State Interface Layer}
\input{state/state/state_top}

\section{State Manipulation Level Lemmas}
\input{state_manipulation/state_manipulation/state_manipulation_auxiliary}
\subsection{State Manipulation Decomposition Rules}
\input{state_manipulation/state_manipulation/flag_decomposition}
\input{state_manipulation/state_manipulation/register_decomposition}
\input{state_manipulation/state_manipulation/memory_decomposition}
\input{state_manipulation/state_manipulation/post_instruction_decomp}
\input{state_manipulation/state_manipulation/state_manipulation_decomposition}
\subsection{State Manipulation Simplification Rules}
\input{state_manipulation/state_manipulation/flag_simps}
\input{state_manipulation/state_manipulation/register_simps}
\input{state_manipulation/state_manipulation/memory_simps}
\input{state_manipulation/state_manipulation/initial_state_simps}
\input{state_manipulation/state_manipulation/standard_error_simps}
\input{state_manipulation/state_manipulation/post_instruction_simps}
\input{state_manipulation/state_manipulation/permission_sets}
\input{state_manipulation/state_manipulation/special_simps}
\input{state_manipulation/state_manipulation/state_manipulation_simps}
\subsection{State Manipulation Reordering Rules}
\input{state_manipulation/state_manipulation/flag_reorder}
\input{state_manipulation/state_manipulation/register_reorder}
\input{state_manipulation/state_manipulation/memory_reorder}
\input{state_manipulation/state_manipulation/state_manipulation_reorder}
\subsection{State Manipulation Interface Layer}
\input{state_manipulation/state_manipulation/state_manipulation_top}

\section{Instruction Level Lemmas}
\input{instruction/instruction/instruction_auxiliary}
\subsection{Instruction Decomposition Rules}
\input{instruction/instruction/ERROR_decomposition}
\input{instruction/instruction/NOP_decomposition}
\input{instruction/instruction/LOAD_IMMEDIATE_decomposition}
\input{instruction/instruction/LOAD_STATIC_DATA_decomposition}
\input{instruction/instruction/STORE_STATIC_DATA_decomposition}
\input{instruction/instruction/LOAD_DYNAMIC_DATA_decomposition}
\input{instruction/instruction/STORE_DYNAMIC_DATA_decomposition}
\input{instruction/instruction/LOAD_INPUT_DATA_decomposition}
\input{instruction/instruction/STORE_OUTPUT_DATA_decomposition}
\input{instruction/instruction/COPY_decomposition}
\input{instruction/instruction/ADD_decomposition}
\input{instruction/instruction/SUBTRACT_decomposition}
\input{instruction/instruction/SHIFT_LEFT_decomposition}
\input{instruction/instruction/SHIFT_RIGHT_decomposition}
\input{instruction/instruction/BITWISE_AND_decomposition}
\input{instruction/instruction/BITWISE_OR_decomposition}
\input{instruction/instruction/BITWISE_XOR_decomposition}
\input{instruction/instruction/BITWISE_NAND_decomposition}
\input{instruction/instruction/BITWISE_NOT_decomposition}
\input{instruction/instruction/LESS_THAN_decomposition}
\input{instruction/instruction/GREATER_THAN_decomposition}
\input{instruction/instruction/EQUALS_decomposition}
\input{instruction/instruction/NOT_EQUALS_decomposition}
\input{instruction/instruction/RANDOMISE_decomposition}
\input{instruction/instruction/END_JUMP_decomposition}
\input{instruction/instruction/END_JUMP_STRICT_decomposition}
\input{instruction/instruction/JUMP_decomposition}
\input{instruction/instruction/CONDITIONAL_JUMP_decomposition}
\input{instruction/instruction/END_CALL_decomposition}
\input{instruction/instruction/CALL_decomposition}
\input{instruction/instruction/END_RETURN_decomposition}
\input{instruction/instruction/RETURN_decomposition}
\input{instruction/instruction/HALT_decomposition}
\input{instruction/instruction/ILLEGAL_decomposition}
\subsection{Instruction Simplification Rules}
\input{instruction/instruction/ERROR_simps}
\input{instruction/instruction/NOP_simps}
\input{instruction/instruction/LOAD_IMMEDIATE_simps}
\input{instruction/instruction/LOAD_STATIC_DATA_simps}
\input{instruction/instruction/STORE_STATIC_DATA_simps}
\input{instruction/instruction/LOAD_DYNAMIC_DATA_simps}
\input{instruction/instruction/STORE_DYNAMIC_DATA_simps}
\input{instruction/instruction/LOAD_INPUT_DATA_simps}
\input{instruction/instruction/STORE_OUTPUT_DATA_simps}
\input{instruction/instruction/COPY_simps}
\input{instruction/instruction/ADD_simps}
\input{instruction/instruction/SUBTRACT_simps}
\input{instruction/instruction/SHIFT_LEFT_simps}
\input{instruction/instruction/SHIFT_RIGHT_simps}
\input{instruction/instruction/BITWISE_AND_simps}
\input{instruction/instruction/BITWISE_OR_simps}
\input{instruction/instruction/BITWISE_XOR_simps}
\input{instruction/instruction/BITWISE_NAND_simps}
\input{instruction/instruction/BITWISE_NOT_simps}
\input{instruction/instruction/LESS_THAN_simps}
\input{instruction/instruction/GREATER_THAN_simps}
\input{instruction/instruction/EQUALS_simps}
\input{instruction/instruction/NOT_EQUALS_simps}
\input{instruction/instruction/RANDOMISE_simps}
\input{instruction/instruction/END_JUMP_simps}
\input{instruction/instruction/END_JUMP_STRICT_simps}
\input{instruction/instruction/JUMP_simps}
\input{instruction/instruction/CONDITIONAL_JUMP_simps}
\input{instruction/instruction/END_CALL_simps}
\input{instruction/instruction/CALL_simps}
\input{instruction/instruction/END_RETURN_simps}
\input{instruction/instruction/RETURN_simps}
\input{instruction/instruction/HALT_simps}
\input{instruction/instruction/ILLEGAL_simps}
\subsection{Individual Instruction Interfaces}
\input{instruction/instruction/ERROR_top}
\input{instruction/instruction/NOP_top}
\input{instruction/instruction/LOAD_IMMEDIATE_top}
\input{instruction/instruction/LOAD_STATIC_DATA_top}
\input{instruction/instruction/STORE_STATIC_DATA_top}
\input{instruction/instruction/LOAD_DYNAMIC_DATA_top}
\input{instruction/instruction/STORE_DYNAMIC_DATA_top}
\input{instruction/instruction/LOAD_INPUT_DATA_top}
\input{instruction/instruction/STORE_OUTPUT_DATA_top}
\input{instruction/instruction/COPY_top}
\input{instruction/instruction/ADD_top}
\input{instruction/instruction/SUBTRACT_top}
\input{instruction/instruction/SHIFT_LEFT_top}
\input{instruction/instruction/SHIFT_RIGHT_top}
\input{instruction/instruction/BITWISE_AND_top}
\input{instruction/instruction/BITWISE_OR_top}
\input{instruction/instruction/BITWISE_XOR_top}
\input{instruction/instruction/BITWISE_NAND_top}
\input{instruction/instruction/BITWISE_NOT_top}
\input{instruction/instruction/LESS_THAN_top}
\input{instruction/instruction/GREATER_THAN_top}
\input{instruction/instruction/EQUALS_top}
\input{instruction/instruction/NOT_EQUALS_top}
\input{instruction/instruction/RANDOMISE_top}
\input{instruction/instruction/END_JUMP_top}
\input{instruction/instruction/END_JUMP_STRICT_top}
\input{instruction/instruction/JUMP_top}
\input{instruction/instruction/CONDITIONAL_JUMP_top}
\input{instruction/instruction/END_CALL_top}
\input{instruction/instruction/CALL_top}
\input{instruction/instruction/END_RETURN_top}
\input{instruction/instruction/RETURN_top}
\input{instruction/instruction/HALT_top}
\input{instruction/instruction/ILLEGAL_top}
\subsection{Instruction Interface Layer}
\input{instruction/instruction/instruction_top}

\section{Execution Level Lemmas}
\input{execution/execution/execution_auxiliary}

\input{execution/execution/invariant_toolkit}
\input{execution/execution/execution_top}

\section{Example Programs}
\input{add_example}
\input{fibonacci_invariant_piecemeal}
\section{Top Level File}
\input{top_proof}

% optional bibliography
%\bibliographystyle{abbrv}
%\bibliography{root}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
